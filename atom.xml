<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JamesXBY的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-10-08T16:11:27.114Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>JamesXBY</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据结构：并查集（1）：基本概念与实现</title>
    <link href="http://yoursite.com/2018/10/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>http://yoursite.com/2018/10/07/数据结构：并查集/</id>
    <published>2018-10-06T16:51:02.000Z</published>
    <updated>2018-10-08T16:11:27.114Z</updated>
    
    <content type="html"><![CDATA[<p>并查集是一种用来维护多个集合（或对象）之间集合关系的数据结构，在很多题目中可以直接应用。它也经常被用在图论的算法优化中，是一种简单实用，又十分重要的数据结构</p><h1 id="题目引入"><a href="#题目引入" class="headerlink" title="题目引入"></a>题目引入</h1><h2 id="例题1"><a href="#例题1" class="headerlink" title="例题1"></a>例题1</h2><p>有n（1 &lt;= n &lt;= 20）个元素，分别属于编号为1-n的集合。现有t（1 &lt;= t &lt;= 20）次询问，每次询问对应如下两种操作：<br>A：将两个元素所在的集合<strong>合并</strong><br>B：<strong>询问</strong>两个元素是否在同一集合中</p><p>解答：直接开数组模拟<br>对于操作A：遍历所有数组，寻找两个元素所在的集合，将一个集合中的元素全部移入另一个集合<br>对于操作B：依然遍历寻找集合，判断集合编号是否相同</p><h2 id="例题2"><a href="#例题2" class="headerlink" title="例题2"></a>例题2</h2><p>题目要求不变，数据范围改为：1 &lt;= n &lt;= 10000, 1 &lt;= t &lt;= 200000</p><p>解答：暴力模拟肯定超时，需要并查集</p><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>并查集是由若干树（又称森林）组成的。起始时所有结点无儿子，且父亲为它本身。  </p><p><div align="center"> <img src="https://i.imgur.com/fBI0lY7.jpg" alt=""><div align="left"><br>在合并操作后，如果两个节点属于同一棵树，那么他们属于同一个集合。换而言之，一棵树的所有节点构成一个集合<br>如图，将1合并到2后，1，2构成一棵树，则1，2属于同一个集合</div></div></p><p><div align="center"> <img src="https://i.imgur.com/nzBzyFa.jpg" alt=""><div align="left"></div></div></p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="储存"><a href="#储存" class="headerlink" title="储存"></a>储存</h2><p>我们一般使用数组来维护并查集：<br>定义一个fa（father）数组，记录每个结点的父节点<br>根据定义，每个结点的父亲需初始化为它自己，即fa[i] = i<br>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//初始化部分</span><br><span class="line">int fa[100005], n;</span><br><span class="line">//n：集合个数</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    for(int i = 1; i &lt;= n; i++)</span><br><span class="line">        fa[i] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>从字面上就能够看出，并查集的基本操作就是“并”和“查”，也就是例题中的两种操作<br>我们先来研究怎么“查”  </p><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>根据定义，我们不难得到这样的性质：</p><blockquote><p>在并查集中，每个结点有且仅有一个最高祖先（即树的根），这个祖先的父亲是他自己 </p></blockquote><p>有了这样的性质，我们不难发现，判断两个结点是否属于同一个集合，等价于判断他们的最高祖先是否相同<br>那么，我们的核心任务便成了如何找到每个结点的最高祖先<br>我们只需要根据fa数组，寻找它的父亲，再寻找父亲的父亲，再寻找父亲的父亲的父亲……<strong>直到找到一个结点，它的父亲是它自己</strong>，那么我们就找到了最高祖先。<br>对于查询操作，我们常用递归写法，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//查找部分</span><br><span class="line">int find(int x) &#123;</span><br><span class="line">    if(x == fa[x])          //x == fa[x]当且仅当x为最高祖先</span><br><span class="line">        return x;</span><br><span class="line">    return find(fa[x]);     //递归找爸爸。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综上所述，我们判断两个结点x, y是否属于同一个集合，只需判断find(x)和find(y)是否相等即可</p><h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><p>那我们怎么将两个结点x, y所在的集合合并为一个集合呢？<br>我们只有一个fa数组，当然还是从它入手了<br>我们发现，除了根结点的fa可以用，其他的fa都不是空闲的：随意改变这些fa的值会让以它为根的子树从原集合脱离<br>所以我们还是要找到根，也就是最高祖先。之前的find()便派上用场了<br>如果我们现在找到了x的最高祖先t，那么我们只需要让fa[t] = y，以t为根的这棵树就成为了y这棵树的子树，那么根据定义，这两个集合便成为一个集合了<br>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//合并操作（有漏洞）</span><br><span class="line">void merge(int x, int y) &#123;</span><br><span class="line">    int t = find(x);</span><br><span class="line">    fa[t] = y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们的想法是正确的，但是遗漏了一点：如果x和y本来就在一个集合中怎么办？如果按我们刚才的想法操作，那么并查集就可能会变成一个有环图，再次find的时候就会死循环<br>所以，我们还要先判断x, y是否属于同一个集合，如果属于，则不进行任何操作<br>到了这里，我们再回想之前的合并操作：我们直接将t并到了y上。其实，我们可以<strong>将t并在y的最高祖先上</strong>，不难发现这样的操作和刚才所能达到的效果是相同的。但是，之前的操作会使下次find的时间增加：合并后，如果find某个原来在x这棵树上的结点，那么它一定要先到y，再从y找到y的最高祖先。而如果直接合并到y的最高祖先，那么就可以跳过y到它的最高祖先这一段路径，时间复杂度减少O(y的深度)<br>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//合并操作</span><br><span class="line">void merge(int x, int y) &#123;</span><br><span class="line">    x = find(x);</span><br><span class="line">    y = find(y);            //将x, y分别赋值为他们各自的最高祖先</span><br><span class="line">    if(x == y)              //如果已经在一个集合，直接返回</span><br><span class="line">        return;</span><br><span class="line">    fa[x] = y;              //将x的最高祖先并到y的最高祖先</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这就是并查集的基本操作，但是，如果数据喜（bian）人（tai），这样朴素的做法还是会超时。下一节将重点介绍并查集的优化策略</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;并查集是一种用来维护多个集合（或对象）之间集合关系的数据结构，在很多题目中可以直接应用。它也经常被用在图论的算法优化中，是一种简单实用，又十分重要的数据结构&lt;/p&gt;
&lt;h1 id=&quot;题目引入&quot;&gt;&lt;a href=&quot;#题目引入&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
      <category term="NOIp" scheme="http://yoursite.com/categories/NOIp/"/>
    
    
      <category term="NOIp" scheme="http://yoursite.com/tags/NOIp/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
</feed>
